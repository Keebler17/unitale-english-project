<!DOCTYPE html>
<!-- 
since you're here anyway: there's a small easter egg on the text commands page but it's probably not worth finding, sorry
you may notice this page's code is garbage: i'm not a web designer! ;-;
it's w3c valid, at least 
-->

<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="favicon.ico">

    <title>UNITALE Documentation</title>
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/bootstrap-theme.min.css" rel="stylesheet">
    <link href="css/themesidebar.css" rel="stylesheet">
    <link href="css/shThemeRDark.css" rel="stylesheet">
    
    <!-- Syntax highlighting -->
    <script type="text/javascript" src="js/shCore.js"></script>
	<script type="text/javascript" src="js/shBrushLua.js"></script>
	<script type="text/javascript">SyntaxHighlighter.all();</script>
  </head>
<body>
<img src="img/bg2.png" alt="Undertale background" class="backimg">
<div class="container arena black">
<div class="col-md-2">
<!--navigation-->
<nav class="nav-sidebar">
    <ul class="nav tabs">
      <li class="li-header">Basics</li>
      <li class="active"><a href="#welcome" data-toggle="tab">Welcome</a></li>
      <li class=""><a href="#controls" data-toggle="tab">Controls</a></li>
      <li class=""><a href="#basic" data-toggle="tab">Basic setup</a></li>
      <li class=""><a href="#terms" data-toggle="tab">Terminology</a></li>
      <li class="li-header">API</li>
      <li class=""><a href="#api-text" data-toggle="tab">Text commands</a></li>
      <li class=""><a href="#api-events" data-toggle="tab">Game events</a></li>  
      <li class=""><a href="#api-functions" data-toggle="tab">Functions &amp; Objects</a></li>      
      <li class=""><a href="#api-projectile" data-toggle="tab">Projectile management</a></li>
      <li class=""><a href="#api-animation" data-toggle="tab">Sprites &amp; Animation</a></li>
      <li class="li-header">Resources</li>
      <li class=""><a href="media/dialogoptions.png">Dialog bubble names</a></li> 
    </ul>
</nav>
</div>
<!--tabs'n'shit-->
<div class="tab-content col-md-10">
<div class="tab-pane active text-style" id="welcome">
  <h2>Welcome to Unitale's documentation!</h2>
       <p><span style="color:#ff0000">NOTE:</span> There will be casual <span style="color:#ff0000">spoilers</span> all over the place. If you haven't played or completed Undertale yet, it's very recommended that you do so first! Don't say you weren't warned.<br>
       <br>
         You probably want to get right in, so let's keep it short. Honestly, the fastest way to get started is to check out the existing encounters and tinker with them. The documentation is for reference if you want to know the specifics of everything. Help is provided on the <a href="http://www.reddit.com/r/Unitale">/r/Unitale subreddit</a>. These are the categories on the left, and what to expect in them:<br>
         <br>
         <i>Basic setup</i><br>
         Details folder structure of mods, how the game reads folders and expects files, that kind of stuff. Recommended to start with.<br>
         <br>
         <i>Terminology</i><br>
         This is a short page on how what things are called in the documentation. For instance, the white box that the bullet dodging occurs in is referred to as the &quot;arena&quot;. Recommended read so you don't get lost in later parts of the documentation.<br>
         <br>
         <i>API - Text commands</i><br>
         This is where all the special commands are that you can use in your dialogue boxes. Text effects, colours, character voices, automatic skipping, you name it. You can even add commands to run Lua code!<br>
         <br>
         <i>API - Game events</i><br>
         If you want to get your hands dirty with Lua, these are the functions the game will use from your script, and at what point they're used. Useful for if you want to have certain events occur during specific times, such as before/after using an act command or item, or just before the fight starts. A must-read for interactive fights.<br>
         <br>
         <i>API - Functions &amp; Objects</i><br>
         These are most custom functions and objects that you can use in your scripts, detailing how to use them and what they do. Want to control the music, check for game events or handle keyboard input? Global variables so you can communicate between scripts? Need to know how much HP the player has, damage them, heal them? This is where to go! Projectile management and sprite management are split off into separate sections below.<br>
         <br>
         <i>API - Projectile management</i><br>
         This is where you can read details about how to create projectiles, what you can do with them and some short examples.<br>
         <br>
         <i>API - Sprites &amp; Animation</i><br>
         This section is about creating sprites and how to control them. By combining the sprite functions, you can create animations.<br>
         <br>
       </p>
</div>

<div class="tab-pane text-style" id="controls">
  <h2>Controls</h2>
   <p><span class="term">Arrow keys, Z (or Enter), X (or left/right Shift)</span> - The same as in Undertale.</p>
   <p><span class="term">Esc</span> - Resets to the Mod Selection screen to assist in quickly testing mods. Will not work on the disclaimer/Game Over screen.</p>
   <p><span class="term">F9</span> - Toggles the debug console. Currently, you can write text to this with DEBUG("your text here") in your scripts.</p>
   <p><span class="term">Alt+Enter</span> - Fullscreens the game. F4 works too, but not on the disclaimer/Game Over screens.</p>
</div>

<div class="tab-pane text-style" id="basic">
  <h2>Basic setup</h2>
   <p>IMPORTANT NOTE: Due to the hasty implementation of file loading, your encounter will currently break if certain folders are missing. To make sure this doesn't happen, please preserve the folder structure of the example mods, <i>even if you have no files in a certain folder.</i> It's an early alpha and we're working on it!</p>
    
   <p>By this point you'll probably want to set up an encounter of your own. Right now, we only have encounters implemented, and even that's still a work in progress! Planning ahead for the future, scripts will eventually be set up as follows:</p>
   <ul>
    <li>Monster scripts - will contain information about your enemies. Here, you'll set things like their ATK, DEF, HP, random comments that might show up as encounter texts, random dialogue, and what ACT commands they have.</li>
    <li>Encounter scripts - will contain a set of monsters, a set of wave scripts (that you can modify at any point), size of the arena, custom interactions for items, etc. <br>
    <br>
    A lot of Unitale's functions will be run on the Encounter scripts first. If there's no custom behaviour on the encounter, many of these functions will then also be run on the Monster scripts. More information on this can be found in the API - Game events section.</li>
    <li>Wave scripts - will contain an update function. You may use these to spawn, track, modify and otherwise interact with bullets during the defending phase of the game.</li>
   </ul>
    <p>Eventually, you will be able to call up your encounter scripts from various places in the overworld. Seeing as we are missing an overworld, the current alpha of the game lets you select which encounter you want to play.</p>
    <hr>
    <h3>Files and directories</h3>
    <p>It's fairly self-explanatory. If you just want to move on fast, feel free to skip this section and go to the next one. If for any reason some of your files don't work, you might want to read this anyway.</p>
    <h4>Scripts</h4>
    <p>The <i>Encounter scripts</i> are located in <i>YOUR MOD/Lua/Encounters/</i>. The <i>Monster scripts</i> are in <i>YOUR MOD/Lua/Monsters/</i>, and your wave scripts at <i>YOUR MOD/Lua/Waves/</i>. If you're getting started, check out these files in example encounters to see how they're put together. Starting from 0.2, there's also an optional <i>YOUR MOD/Lua/Libraries/</i> folder. You can put libraries other people have made in here (or create your own) for use in your other scripts. Libraries/modules are more Lua functionality than they are Unitale functionality, so please read up about them <a href="http://lua-users.org/wiki/ModulesTutorial">here</a> instead. There is an example encounter included making use of one such library.</p>
    <h4>Music</h4>
    <p>Music can be put in <i>YOUR MOD/Audio/</i>. Your music must be in .ogg or .wav format. <a href="http://audacityteam.org/download/">Audacity</a> can export to .ogg if you're missing the appropriate software.</p>
    <h4>Sounds</h4>
    <p>Sounds can be put in <i>YOUR MOD/Sounds/</i>. They must be in .ogg or .wav format. You can play them with <i>Audio.PlaySound(filename)</i>; more on this in <i>API - Functions &amp; Objects</i>.</p>
    <h4>Voices</h4>
    <p>Voices can be put in <i>YOUR MOD/Voices/</i>. They must be in .ogg or .wav format, although .wav is generally recommended. You can use them with the [voice] text command; more on this in <i>API - Text commands</i>.</p>
    <h4>Sprites</h4>
    <p>Sprites can be put in <i>YOUR MOD/Sprites/</i>. They must be in the .png format. Note that most vanilla Undertale monster sprites start with a small base resolution, then resize the sprite to 2x its original resolution for an oldschool look. To <i>add a background</i> you can have one file titled <i>bg.png</i> in the sprites folder. This image will stretch over the entire background, so 640x480 resolution is recommended. This is <i>not</i> the final solution for backgrounds; it just beats not having one.</p>
    <hr>
    <h3>The Default directory</h3>
    <p>Starting from 0.2 Unitale now has a default directory. This is where resources from Undertale reside. It is not advised to modify files in this directory, as they are expected to be the same across all installations. <br><br>If you wish to replace any of the files for your mod, create a file with the same name at the same location instead. For instance, if you want to change the player soul hurt sound, don't replace <i>Default/Sounds/hurtsound.wav</i>. Instead, create a new file located at <i>YOUR MOD/Sounds/hurtsound.wav</i>.</p>
    <hr>
    <h3>Basic variables and their usage</h3>
    <p>Now that all of that's out of the way, it's time to set up the basics of an encounter! The fastest way to get started is to copy the 'Encounter Skeleton' mod and play with the values in it, then either copying over existing examples' code, or writing your own. This section serves to explain the variables you see.</p>
    <h4>Encounter script variables</h4>
      <div class="code-container">
<pre class="brush: lua;">music = "yourmusicname_without_extension"
encountertext = "Vegetoid came out of\rthe earth!"
nextwaves = {"bullettest_wavy", "bullettest_homing"}
wavetimer = 4.0
arenasize = {155, 130}

enemies = { "vegetoid" }

enemypositions = {
{0, 50},
{-70, 30},
{70, 30}
}

</pre></div>
<p>music - Name of your encounter's starting music, without the file extension. If this variable isn't present, it'll play Undertale's default battle theme. If you don't want any music, call <i>Audio.Stop()</i> in the <i>EncounterStarting()</i> function. For more information see <i>API - Game events</i>.</p>
<p>encountertext - Set the initial text of your encounter here. After that, you can modify it at any time in preparation for the next turn. <i>encountertext</i> gets read out at the start of every new turn (i.e. you going back to the FIGHT/ACT/ITEM/MERCY selection).</p>
<p>nextwaves - A list of all simultaneous attack waves you want when the monsters start their attacks. You can modify this at any time, and it'll get read out before the enemies start their attack. For most boss-type encounters, you'll likely only want one wave simultaneously - but you can get creative here.</p>
<p>wavetimer - How long it takes for the defending step to end. If this isn't set anywhere, it'll be the default <i>4.0 seconds</i>.</p>
<p>arenasize - The inner size of the box the player's constrained to. {155, 130} is the default size for a lot of basic Undertale encounters. Papyrus' battle, for instance, has this at {245, 130} most of the time. You may modify this at any time - it'll only get read out before the enemies start their attack.<br>
Note: lowest possible setting is {16, 16} - this is the size of the player's soul. Anything lower will be set to 16 anyway.</p>
<p>enemies - Defines the names of your enemy scripts that will be used in your encounter. In this example. <i>vegetoid.lua</i> will be used from the Monsters folder. After initialization, the names will be replaced by Script controller objects you can use to control your monster scripts. Refer to <i>API - Functions &amp; Objects</i> for more information.</p>
<p>enemypositions - Defines where the enemies are on the screen. {0, 0} means they're centered just above the arena, with 1 pixel of space inbetween. {-30, 0} means above the arena to the left; {50, 80} means 50 pixels to the right and 80 pixels above that center.<br>
You will always need at least as many enemy positions as enemies in your encounter. In this example we have 3 enemy positions set to show you how you can define more than one, but since this example only contains Vegetoid you only really need one position.</p>
<hr>
    <h4>Monster script variables</h4>
<div class="code-container">
<pre class="brush: lua;">comments = {"Vegetoid cackles softly.", "Vegetoid's here for your health."}
commands = {"Talk", "Devour", "Dinner"}
randomdialogue = {"Fresh\nMorning\nTaste", "Farmed\nLocally,\nVery\nLocally"}
currentdialogue = {'Eat\nYour\nGreens'}
cancheck = true
canspare = false

sprite = "vegetoid_sprite"
dialogbubble = "rightshort"
name = "Vegetoid"
hp = 20
atk = 6
def = 6
xp = 6
gold = 1
check = "Serving Size: 1 Monster\nNot monitored by the USDA"</pre></div>
<p>comments - A list of random comments attached to this monster. You can retrieve one at random using the RandomEncounterText() function in your Encounter script. See <i>API - Functions &amp; Objects</i> for details.</p>
<p>commands - A list of ACT commands you can do. Listed in the ACT menu and used in HandleCustomCommand(). See <i>API - Game events</i> for details. Note that the behaviour for Check is built-in, and shows you the monster's <i>name</i> followed by the <i>ATK</i> and <i>DEF</i>, and then the <i>check</i> variable you'll see all the way down.</p>
<p>randomdialogue - A list of random dialogue the monster can have. One of these is selected at random if <i>currentdialogue</i> is <i>nil</i> (i.e. has no value).</p>
<p>currentdialogue - The next dialogue for this monster. This overrides the random dialogue and is meant for special actions (e.g. you hit Vegetoid's green carrots after selecting Dinner from the ACT menu). This variable gets <i>cleared every time after it's read out in the monster dialogue phase</i>. This is done so you don't have to take care of managing it manually.</p>
<p>cancheck - Either true or false. You can leave this line out; it will be true by default. If set to false, it will disable the default Check action that shows up in your ACT menu. If you want a custom Check action, you can add it back into your <i>commands</i> table, and handle it like any other custom command. See <i>API - Game events</i> for details.</p>
<p>canspare - Either true or false. If you leave this line out, it'll be set to false by default. If you change this to true, your monster's name will turn yellow and it will be spareable.</p>
<br>
<p>sprite - Name of the sprite in your Sprites folder, without the .PNG extension. This is the initial sprite for your monster. It can be changed using SetSprite(name); see <i>API - Functions &amp; Objects</i> for details.</p>
<p>dialogbubble - What dialogue bubble will be used for the monster's dialogue. You can change this at any time, but this <i>must</i> be initially set to something. For a list of all possible options, check the <a href="media/dialogoptions.png">dialog bubble names</a> chart; it's also in the sidebar.</p> Positioning of the bubbles is done automatically.
<p>name - Monster name. Fairly self-explanatory; shows up in the FIGHT/ACT menus. Can also be changed at any time.</p>
<p>hp - Your monster's max HP, initially. After the fight has started this value will always accurately reflect your monster's current HP. You can then modify this value to change your monster's current HP.</p>
<p>atk - Your monster's ATK. Only used in the default Check handler; bullet damage is set through wave scripts. If you're not using the default Check you can leave this out.</p>
<p>def - Your monster's DEF.</p>
<p>xp - Your monster's XP upon actually defeating them. You only get this by killing the monster. Currently unused.</p>
<p>gold - Gold you get from either killing or sparing this monster. Since the gold can change based on whether you kill or spare the monster, you can modify this at any time up until the fight ends. Currently unused.</p>
<p>check - When checking with the default Check option, this is what's listed under the monster's name, ATK and DEF.</p>
<hr>
    <h4>Wave script variables</h4>
<p>Wave scripts don't have any variables that are read out from the start, but you can define your own. An instance of a wave script is made when you start defending, and is destroyed when the defending step ends. As such, you can't store variables in a wave script for reusing later. Use the Encounter script to keep track of things, or the SetGlobal/GetGlobal functions (<i>API - Functions &amp; Objects</i> for details).</p>
</div>

<div class="tab-pane text-style" id="terms">
  <h2>Terminology</h2>
   <p><span class="term">arena</span> - The inside of the white box in which the player is allowed to move.</p>
   <p><span class="term">bullet</span> - Everything in a wave that can collide with you. Flowey's pellets would be referred to as bullets, but so would Papyrus' bones, anything Woshua can shoot (of any colour), even the dancing Migosp.</p>
   <p><span class="term">encounter text</span> - The text that shows up before you've selected FIGHT/ACT/ITEM/MERCY.</p>
   <p><span class="term">monster dialogue</span> - Text from monsters in an encounter, often seen before attacking. Can also be multiple dialogue boxes for special encounters.</p>
   <p><span class="term">dialog</span> - A user interface component that contains text. For example, the battle dialog window. The distinction between dialog and dialogue is that dialog refers to interface windows containing text, and dialogue refers to the speech content of monsters.</p>
   <p><span class="term">wave</span> - A single attack behaviour (or attack 'wave', to say), measured from when you start defending until when it stops. Vegetoid's bouncing vegetables attack would count as a wave. Papyrus' special Cool Dude attack would also count as a wave. Unitale works with 'wave scripts' for attacks; you can use multiple wave scripts at the same time for when you have various monsters.</p>
</div>

<div class="tab-pane text-style" id="api-text">
  <h2>Text commands</h2>
   <p>There are <b>two types</b> of text commands: commands that get executed <i>instantly</i>, like text color and effects; and commands that get executed <i>inline</i>, as they're displayed, like wait commands and character voices. Note that currently, if you skip a text command (with X), it'll also skip all inline commands that were still in your text.</p>
   
   <p>On line breaks: there are actually two different kinds. In <i>UI messages</i> where asterisks are used, you can use <b>\n</b> to start a new line <i>with</i> an asterisk. If you want a new line <i>without</i> an asterisk, use <b>\r</b>.</p>
   
   <p>This is different for monster dialogue that isn't prefixed with asterisks: <i>Always</i> use \n for line breaks here.</p>
    
    <h3>Instant commands</h3>
   <p class="exblock">
   <span class="function">[color:rrggbb]</span>
   This sets the text color for all text after this command to the specified hex code. It resets per dialogue. [color:ff0000] would be red, [color:555555] a dark grey. The main colours the game uses are as follows:</p>
      <table class="table">
       <tr><td>[color:ff0000]</td><td><span style="color:#ff0000">Determination</span></td></tr>
       <tr><td>[color:003cff]</td><td><span style="color:#003cff">Integrity</span></td></tr>
       <tr><td>[color:00c000]</td><td><span style="color:#00c000">Kindness</span></td></tr>
       <tr><td>[color:ffff00]</td><td><span style="color:#ffff00">Justice</span></td></tr>
       <tr><td>[color:d535d9]</td><td><span style="color:#d535d9">Perseverance</span></td></tr>
       <tr><td>[color:fca600]</td><td><span style="color:#fca600">Bravery</span></td></tr>
       <tr><td>[color:42fcff]</td><td><span style="color:#42fcff">Patience</span></td></tr>
   </table>
   <p class="exblock">
   If you have to use colours, try to stick to these. While the option for any colour is offered, actual usage in Undertale is very limited.<br>
   <br>
   The default UI text is plain white and the default enemy dialogue text is plain black; [color:ffffff] and [color:000000] respectively.
   </p>
   
   <p class="exblock">
   <span class="function">[starcolor:rrggbb]</span>
   Same usage as color but <i>only affects the first asterisk in a dialogue box that has asterisks.</i> This is a dirty workaround as there's no other way to change the colour of the first asterisk otherwise. It'll be changed at some point.
   </p>
   
   <p class="exblock">
   <span class="function">[noskip]</span>
   Prevents this dialogue from being skipped by pressing X. Has no effect in encounter texts as you don't control that.
   </p>
   
   <p class="exblock">
   <span class="function">[instant]</span>
   Instantly shows the entire text without having to wait or press anything.
   </p>
   
   <p class="exblock">
   <span class="function">[effect:x]</span> or
   <span class="function">[effect:x,intensity]</span>
   Sets the text effect for <i>the entire message, regardless of position</i>. You can use the following effects:</p>
    <ul>
    <li>none: No effect on the text.</li>
    <li>rotate: Rotating text, most random monsters have this by default. Intensity sets how far letters rotate, in pixels. Default is 1.5.</li>
    <li>shake: Shaking text. Flowey uses this sometimes. Intensity sets how far the letters offset, in pixels. Default is 1.0.</li>
    <li>twitch: Letters twitch occasionally, battle UI has this by default. Intensity sets how far a letter should shake. Default is 2.0.</li>
   </ul>
   <p class="exblock">
   Note that the twitch effect should, at a later point, let you set shake frequency. Unfortunately you can't do this yet.
   </p>
   
      <p class="exblock">
   <span class="function">[font:x]</span>
   Sets the font for this dialogue. Usually includes a default voice. As the [font] command can change both text colour and voice, if you want to have your own voice/text color do it after the font change. Possible options:</p>
      <ul>
    <li>uidialog: Default large pixel font for UI.</li>
    <li>monster: Default font for almost all monsters in the game.</li>
    <li>sans: sans. use lowercase. uppercase works, but... sans.</li>
    <li>papyrus: PAPYRUS! USE UPPERCASE ONLY. LOWERCASE WON'T WORK.</li>
    <li>wingdings: Wingdings.</li>
    <li>uibattlesmall: The font used for the character name, HP and level.</li>
   </ul>
   <p>For all default fonts, check out the Default/Sprites/UI/Fonts folder. Every font with a matching .xml file is mapped.</p>
   
   <h3>Inline commands</h3>
   <p class="exblock">
   <span class="function">[w:x]</span>
   The wait command. This will pause your textbox for x frames.
   </p>
   
   <p class="exblock">
   <span class="function">[waitall:x]</span>
   Like the wait command, but applies to all letters after this command. It resets per dialogue. Useful for slow text.
   </p>
   
   <p class="exblock">
   <span class="function">[voice:filename]</span>
   Sets the voice (sound per letter) to a sound located in YOUR MOD/Sounds/Voices. Applies to all letters after the command. It resets per dialogue. This has to be a .wav file, and you shouldn't include the file extension when using [voice]. If your voice sound is YOUR MOD/Sounds/Voices/mettaton.wav, you can use it with [voice:mettaton].<br>
   [voice:default] resets to the default voice (beeps). If you have a voice sound named 'default', it will be ignored.</p>
   
   <p class="exblock">
   <span class="function">[novoice]</span>
   Removes the voice for the letters after this command. It resets per dialogue. <span style="color:#000">Useful for when you should be burning in hell.</span></p>
   
   <p class="exblock">
   <span class="function">[next]</span>
   Skips to the next dialogue automatically. You can also use this for textbox trickery. Here's an example to replicate Flowey's text-changing effect if you dodge the Friendliness Pellets(tm) twice.
   </p>
      <div class="code-container">
   <pre class="brush: lua;">first line:  "[noskip][voice:flowey][effect:none]RUN. [w:30]INTO. [w:30]THE.\n[w:30]BULLETS!![w:30][next]"
second line: "[instant][effect:none]RUN. INTO. THE.\nfriendliness\npellets"</pre>
   </div>
   
   <p class="exblock">
   <span class="function">[func:x]</span> or
   <span class="function">[func:x,argument]</span>
   The most powerful command. If the previous text commands were established official characters, [func] is some kid's deviantArt original character that never dies and has all the superpowers.<br>
   <br>
   In all seriousness, [func] allows you to execute <i>any function from your script in line with the text</i>. Refer to the examples below.</p>
      <div class="code-container">
   <pre class="brush: lua;">your dialogue: "hoi hoi this is dog [func:dog] and now the music changed" 
   
function dog()
    Audio.LoadFile("dog_music") --plays dog_music.ogg (or .wav) from your Audio folder! for built-in functions like this, refer to section API - Functions &amp; Objects
    --insert more code here, any code!
end</pre>
   </div>
   
      <div class="code-container">
   <pre class="brush: lua;">your dialogue: "dog with arguments!! [func:newmusic,temietheme] so intense!" 
   
function newmusic(yourargumentname)
    Audio.LoadFile(yourargumentname) --with this example, it'll load 'temietheme.ogg (or .wav)'...
    --and then play it! THE FUTURE IS NOW! By using an argument, your function can be more versatile.
end</pre>
   </div>
</div>

<div class="tab-pane text-style" id="api-events">
  <h2>Game events</h2>
  <p>This section is all about game events. Game events are functions in your scripts that the Unitale engine runs at various points in the game. By changing up your behaviour depending on the actions the player takes, you can go beyond a basic encounter and make it great.</p>
  <p>Waves (currently) only have one function; <i>Update()</i>. Most of the information on programming waves is in the <i>Functions</i> section of the documentation.</p>
  <p>There are two kinds of events. We'll refer to them as <i>inherited events</i> and <i>script-specific events</i>. An <i>inherited event</i> is a function that gets run first on your Encounter script. If the function is not found in the Encounter script, it will try to run the same function on all monsters. If it's not found there either, it will resort to a default, built-in handler. <i>Script-specific events</i> are, as the name implies, functions that only happen for this specific script type. We'll start with the first type.</p>
  <hr>
  <h3>Inherited events (Encounter -> Monster)</h3>
      <p>
  <span class="function">EncounterStarting()</span>
  Happens once when everything's done initializing but before any encounter actions start. You should do things like stopping the music here, or using State() if you want to start the fight off with some dialogue.
  </p>
      <p>
  <span class="function">EnemyDialogueStarting()</span>
  Happens when you go to the monster dialogue state. You're still free to modify monster dialogue here.
  </p>
    <p>
  <span class="function">EnemyDialogueEnding()</span>
  Happens when you go from the monster dialogue state to the defending state.
  </p>
  <p>
  <span class="function">DefenseEnding()</span>
  Happens when you go from the defending state of the game to any other state. If you read up on the RandomEncounterText() function, you'll want to use it here.
  </p>
    <p>
  <span class="function">HandleItem(item_ID)</span>
  Happens when you select an item from the item menu. In this alpha you will only have TestDog1 through TestDog7. The item IDs for these, if you want to use them for some reason, are DOGTEST1 through DOGTEST7. Note that if you do have a custom item handler, using BattleDialog() is mandatory, as selecting an item will not change the game's state by default. Currently, having a custom handler prevents the regular item's handler from working. This will be fixed later, but has been delayed as you can't create custom items yet.
  </p>
  <div class="code-container">
  <pre class="brush:lua;">
function HandleItem(ItemID)
    if ItemID == "DOGTEST2" then
        BattleDialog({"You selected The Second Dog.", "You are truly great."})
    else
        BattleDialog({"You didn't select The Second Dog.", "You could've picked better."})
    end
end
</pre></div>
      <p>
  <span class="function">HandleSpare()</span>
  Happens when you select the Spare option from the Mercy menu, regardless of whether a monster is spareable or not. This event fires <i>after</i> the sparing of monsters is completed. If you spare the last enemy in the encounter, this function will not happen - the encounter is over at that point.
  </p>
  
  <h3>Script-specific events</h3>
  <h4>Encounter script events</h4>
  <p>
  <span class="function">EnteringState(newstate, oldstate) [E]</span>
  A new, more flexible way of handling state changes. When you enter a new state, this function will fire with <i>newstate</i> containing the new state's name, and <i>oldstate</i> containing the previous state's name. Both are in all caps. One of the most powerful things about it is that you can use State() here to interrupt state changes initiated by the engine itself.
  <br>
  Possible states and when they execute are below:
  </p>
    <ul>
   <li>ACTIONSELECT - Returning to the main part of the battle, where you can select FIGHT/ACT/ITEM/MERCY.</li>
   <li>ATTACKING - When you've selected a target with the FIGHT option.</li>
   <li>DEFENDING - When the enemy/enemies finish dialogue, and one or more waves start.</li>
   <li>ENEMYSELECT - When you've selected either FIGHT or ACT, and need to select an enemy.</li>
   <li>ACTMENU - When you've selected an ACT target, and must now select an ACT command.</li>
   <li>ITEMMENU - When you've selected ITEM.</li>
   <li>MERCYMENU - When you've selected MERCY.</li>
   <li>ENEMYDIALOGUE - When your enemy/enemies start their dialogue.</li>
   <li>DIALOGRESULT - When you call BattleDialog(), or when the UI shows text on its own (e.g. when using an item).</li>
  </ul>
  
  For a clearer example, here's a code snippet replicating the older events above.
    <div class="code-container">
  <pre class="brush:lua;">
function EnteringState(newstate, oldstate)
    if newstate == "ENEMYDIALOGUE" then
        --same as EnemyDialogueStarting()
    elseif newstate != "ENEMYDIALOGUE" and oldstate == "ENEMYDIALOGUE" then
        --same as EnemyDialogueEnding(). Alternatively, check for newstate == "DEFENDING"
    elseif newstate != "DEFENDING" and oldstate == "DEFENDING" then
        --same as DefenseEnding()
    end
end
</pre></div>  
    <p>
  <span class="function">Update()</span>
  This function runs for every frame for all of the encounter, even during waves. For advanced users: the Update function is required to exist at the beginning of the encounter. If you define it at a later point in time, it will not get executed.
  </p>
  
  <h4>Monster script events</h4>
  <p>
  <span class="function">HandleAttack(damage)</span>
  Happens the moment the player's attack has applied damage - this is when you hear the hitting sound after the slash animation. <i>damage</i> will be -1 if the player pressed Fight, but didn't press any buttons and let it end by itself. The monster's <i>hp</i> variable will have updated at this time, too. Don't call BattleDialog() here, it's a bit buggy right now.
  </p>
    <p>
  <span class="function">OnDeath()</span>
  Happens after your attack's shaking animation has completed and the monster's HP is 0. If you implement OnDeath(), your monster will not die automatically, and you will have to do it manually with the Kill() function. OnDeath() will only happen through monster kills that happened with the FIGHT command; scripted Kill() calls will not trigger it. Calling BattleDialog() here will probably screw up the battle UI.
  </p>
    <p>
  <span class="function">HandleCustomCommand(actcommand)</span>
  Happens when you select an Act command on this monster. <i>actcommand</i> will be the same as how you defined it in the <i>commands</i> list, except it will be <i>in all caps</i>. Intermediate example below, showing how you can use it and spice it up a little.
  </p>
  <div class="code-container">
  <pre class="brush:lua;">
commands = {"Sing", "Dance", "Wiggle"} --somewhere at the beginning
wigglecounter = 0 --let's keep a counter to check how often we've wiggled
  
function HandleCustomCommand(command)
    if command == "SING" then
        BattleDialog({"You sing your heart out. It's in the arena now."})
    elseif command == "DANCE" then
        BattleDialog({"You busted out your best moves."})
    elseif command == "WIGGLE" then
        if wigglecounter == 0 then --you can use variables to make commands more exciting!
            BattleDialog({"You just kind of stood there and wiggled."})
        elseif wigglecounter == 1 then
            BattleDialog({"You're still kind of standing there and wiggling."})
        else
            BattleDialog({"Your wiggled so often that your wiggling technique\ris now legendary."})
        end
        wigglecounter = wigglecounter + 1 --be sure to increase the wiggle counter, or it'll stay at 0
    end
end
</pre></div>  
  <h4>Wave script events</h4>
  <p>
  <span class="function">Update()</span>
  Happens every frame (usually at 60FPS) while monsters are attacking (the defense step). That's pretty much it. Update your bullets here - more on bullet creation and control is on the <i>API - Projectile management</i> page.
  </p>
</div>

<div class="tab-pane text-style" id="api-functions">
  <h2>Functions &amp; Objects</h2>
  <p>
  This section details functions Unitale adds to your Lua scripts to interact with the game in various ways. All functions will have a suffix in square brackets to denote in which scripts they may be used. The key for this is E for Encounter, M for Monster and W for Wave. If, for example, a function can be used in all scripts, it will be written as <i>functionName() [E/M/W]</i>.
  </p>
  
  <p>
  <span class="function">DEBUG(text) [E/M/W]</span>
  Write text to the debug console (toggleable with F9). It will appear automatically the first time you write text to it. You can use this to check values in your code, or make sure some pieces of code are actually running.
   </p>
  
  <p>
  <span class="function">SetGlobal(your_variable_name, value) [E/M/W]</span>
  Set a global variable. After setting, you can retrieve it from all your scripts at any time with GetGlobal(variable_name).
   </p>
   
   <p>
  <span class="function">GetGlobal(your_variable_name) returns variable [E/M/W]</span>
  Get a global variable that you previously set using SetGlobal().
   </p>
   
   <p>
  <span class="function">BattleDialog(list_of_strings) [E/M/W]</span>
  This makes the list of strings you give the function appear in the UI dialog box. After skipping through them, you will automatically go to the monster dialogue step by default. Below is a working example of how you could use it for a Vegetoid encounter.
   </p>
      <div class="code-container">
   <pre class="brush: lua;">
function HandleCustomCommand(command)
    if command == "DINNER" then
        if ate_greens then -- ate_greens is a non-default variable, of course
            currentdialogue = {"Ate\nYour\nGreens"}
        else
            currentdialogue = {"Eat\nYour\nGreens"}
        end
        BattleDialog({"You pat your stomach.\nVegetoid offers a healthy meal."})
    end
end
</pre>
  <p>(For the Lua specialists; it is indeed a table of strings rather than a list of strings.)</p>
</div>

 <p>
  <span class="function">State(state_to_go_to) [E/M/W]</span>
  A powerful function that immediately skips the battle to the specified state, rather than following the default conventions. Below is a list of valid strings you can pass to it, what state you'll be going to and what that state entails. The states you pass to it are case-invariant, but uppercase is recommended for readability.</p>
  <ul>
   <li>ACTIONSELECT - While in this state, you can select FIGHT/ACT/ITEM/MERCY.</li>
   <li>ENEMYDIALOGUE - When starting this state, <i>currentdialogue</i> gets read from the Encounter script for every monster and their dialogue is displayed. If that doesn't exist it'll return something at random from the <i>randomdialogue</i> list.</li>
   <li>DEFENDING - When starting this state, <i>nextwaves</i> is read out from the Encounter script and all scripts in the Waves folder with matching names will be part of this defense step. <i>wavetimer</i> is also read from the Encounter script at this time.</li>
   <li>DONE - Currently, this immediately returns you to the mod selection screen.</li>
  </ul>
  <p>
  Arguably the best part about State is that it can be used in conjunction with the text command [func] to change the state from within your dialogue. An example below; this will have a monster say that he will not fight you, then return to the action select screen rather than launching an attack.</p>
  <div class="code-container">
   <pre class="brush: lua;">currentdialogue = {"I won't fight you.", "[func:State,ACTIONSELECT]"}</pre>
  </div>
  <p>
  There are other states available, but they can't be properly used. For the sake of completeness I will list them here and you are free to attempt something with them, but will not explain further as they'll likely lock up the battle and their use is entirely unsupported. A better way to manage the state of the battle will be added eventually.<br>
  <br>
  The other states are as follows: ATTACKING, ENEMYSELECT, ACTMENU, ITEMMENU, MERCYMENU, RESETTING, DIALOGRESULT.</p>
   
       <p>
  <span class="function">The Player object [E/M/W]</span>
  You can use this object to obtain information about the player. Since the player is always 16x16 pixels in Undertale, you can add/subtract 8 from the player's horizontal/vertical position to get the player's edges if you need that for anything.
   </p>
  <ul>
   <li>Player.sprite - the Player's soul sprite component. See the Sprites &amp; Animation section for usage details.</li>
   <li>Player.hp - get or set the player's current HP. Can't exceed max HP. If set to 0, game over triggers.</li>
   <li>Player.name - get or set the player's current name. 6 letters max. Random name by default.</li>
   <li>Player.lv - get or set the player's current level. 1 by default/minimum. 20 max. Player starts with 20HP / 10 ATK and gets 4 HP / 2 ATK per level. Leveling up the player through code doesn't automatically heal them; you'll have to do this manually.</li>
   <li>Player.x (readonly) - get the X position of the <i>player's center</i> relative to the arena's center.</li>
   <li>Player.y (readonly) - get the Y position of the <i>player's center</i> relative to the arena's center.</li>
   <li>Player.absx (readonly) - get the X position of the <i>player's center</i> relative to the bottom left corner of the screen.</li>
   <li>Player.absy (readonly) - get the Y position of the <i>player's center</i> relative to the bottom left corner of the screen.</li>
   <li>Player.isHurting (readonly) - true if the player's currently blinking due to being hurt, false otherwise.</li>
   <li>Player.isMoving (readonly) - true if the player is currently moving in battle, false otherwise. Will always be false while not in a wave script.</li>
   <li>Player.Hurt(damage) - deals damage to the player, and makes them invincible for the default time.</li>
   <li>Player.Hurt(damage, invul_time) - deals damage to the player, and makes them invincible for <i>invul_time</i> seconds.</li>
   <li>Player.Heal(value) - heals the player for this amount. This is exactly the same as Player.Hurt(-value, 0).</li>
   <li>Player.SetControlOverride(boolean) - either true or false. Only useable in waves. If true, this will prevent the player soul from doing its regular movement/keyboard control for the rest of the wave. Used for if you want to implement your own controls for a wave.</li>
   <li>Player.MoveTo(x, y, ignoreWalls) - Moves to player soul to this position relative to the arena's center. If ignoreWalls is false, it will make sure the player doesn't go outside of the arena, otherwise it ignores the boundaries. If you want to move the player out of bounds in a wave, you'll have to call Player.SetControlOverride(true) as the player's default movement keeps the soul inside the arena.</li>
   <li>Player.MoveToAbs(x, y, ignoreWalls) - Moves player soul to this position relative to the bottom left of the screen. If ignoreWalls is false, it will make sure the player doesn't go outside of the arena, otherwise it ignores the boundaries. If you want to move the player out of bounds in a wave, you'll have to call Player.SetControlOverride(true) as the player's default movement keeps the soul inside the arena.</li>
  </ul>
  
  <p>
  <span class="function">The Script object (and the Encounter object) [varies]</span>
  Script objects are a bit of a special case. They're used to refer to other scripts that were loaded by the engine itself. In the encounter script, the <i>enemies</i> table is filled with Script objects after the encounter starts. The Encounter object is also a script object that refers to the current encounter, and is accessible from anywhere. Take note of the different way of accessing variables.
  </p>
  <ul>
   <li>script.GetVar("variable_name") - gets variable_name from the script.</li>
   <li>script["variable_name"] - same as the above.</li>
   <li>script.SetVar("variable_name", value) - sets variable_name on the script.</li>
   <li>script["variable_name"] = value - same as the above.</li>
   <li>script.Call("function_name") - runs function_name from within the script.</li>
  </ul>

  <p>So for instance, you can do enemies[1].Call("Kill") to kill the first monster from your encounter. You can do Encounter.SetVar("wavetimer", 1.0) from anywhere to change the wave timer to 1 second.</p>  
 
      <p>
  <span class="function">The Audio object [E/M/W]</span>
  The Audio object allows you to control music in the game and play sounds. Here's the ways in which you can use it.
   </p>
   <ul>
    <li>Audio.Play() - Play the currently loaded music. Done automatically at the beginning of a fight.</li>
    <li>Audio.Stop() - Stops the music. If you want a battle not to have music, call this in <i>EncounterStarting()</i>.</li>
    <li>Audio.Pause() - Pause the music.</li>
    <li>Audio.Unpause() - Unpause the music if you previously paused it.</li>
    <li>Audio.Volume(value) - Set music to given volume. <i>value</i> should be between 0.0 (muted) and 1.0 (full volume). This is 0.75 by default.</li>
    <li>Audio.Pitch(value) - Set music pitch to given value. 1.0 is default, 2.0 is twice the regular speed. Negative values play the music backwards. <i>value</i> should be between -3.0 and 3.0.</li>
    <li>Audio.LoadFile(filename) - Load music from the Audio folder titled <i>filename.ogg</i> or <i>filename.wav</i> and play it immediately. If you don't want immediate playback, call <i>Audio.Stop()</i> after this.</li>
    <li>Audio.PlaySound(filename) - Play the sound from the Sounds folder titled <i>filename.ogg</i> or <i>filename.wav</i>.</li>
    <li>Audio.playtime - Get the current play position of the current music in seconds.</li>
    <li>Audio.totaltime - Get the total length of the current music in seconds.</li>
   </ul>
   
   <p>As it's an object, you can't directly use it with [func], but you can make your own function if you want to, say, stop the music mid-dialogue.</p>
     <div class="code-container">
   <pre class="brush: lua;">currentdialogue = {"but then I realized...\n[w:30][func:drama]the butler did it!!!"}
   
function drama()
    Audio.Stop()
    Audio.PlaySound(dramatic_sound_effect)
end</pre>
  </div>
  
        <p>
  <span class="function">The Input object [E/M/W]</span>
  The Input object allows you to retrieve input status. All keys will return a number; 0 when not pressed, 1 on the first frame the key is pressed, 2 while it's being held, and -1 while it's released. You can check if a key's value is greater than 0 to see if it's pressed, or if it's exactly 1/-1 to only have an action if it was just pressed/released. Possible key options are below.<br>
  <br>
  Note: do not rely on the Input object to replace proper UI controls. Changing game state in the UI based on input will likely cause a fair share of issues and is not supported at this moment (but feel free to see what does and doesn't work).
   </p>
   <ul>
    <li>Input.Confirm - Z or Enter keys</li>
    <li>Input.Cancel - X or left Shift keys</li>
    <li>Input.Menu - C or left Control keys (currently unused anywhere else)</li>
    <li>Input.Up - Up arrow</li>
    <li>Input.Down - Down arrow</li>
    <li>Input.Left - Left arrow</li>
    <li>Input.Right - Right arrow</li>
   </ul>
   
           <p>
  <span class="function">The Time object [E/M/W]</span>
  The Time object serves as a way to retrieve game timing without having to keep track of it yourself, or using a frame counter. Whenever possible, try using the Time object over a frame-based timing method to ensure equal behaviour across all framerates.
   </p>
   <ul>
    <li>Time.time - Time (in seconds) since the game application started. If you want to time specific events, store Time.time in a variable of your own at the start of what you want to time, then subtract Time.time from your stored time to calculate the difference.</li>
    <li>Time.dt - Delta time (in seconds). This is the time it took for the last game update to complete.</li>
    <li>Time.mult - Multiplier to ensure equal movement across all framerates (this is essentially deltatime*framerate). This will be around 1.0 when the application runs at 60FPS, ~0.5 at 120FPS and ~2.0 at 30FPS, etc. By multiplying your movement by this value, your waves will be consistent on lower framerates as well.</li>
   </ul>
   
         <p>
  <span class="function">SetSprite(filename) [M]</span>
  Sets the monster's sprite from the Sprites folder to <i>filename.png</i>. Can be used with [func] to change sprites mid-dialogue.
   </p>
   
   <p>
   <span class="function">SetActive(active) [M]</span>
   Either true or false. If false, this monster will stay on screen but will not show up in menus, do its dialogue or run any of its events. You can use this to introduce monsters to an encounter at a later point. The battle will end when a monster is killed or spared and there are no active monsters left. Having no active monsters at all will likely cause a bunch of errors right now.
   </p>
   
   <p>
   <span class="function">Kill() [M]</span>
   Kills the monster immediately. If this was the last monster, the battle ends.
   </p>
   
      <p>
   <span class="function">Spare() [M]</span>
   Spares the monster immediately. Similar to Kill(), if this was the last monster, the battle ends.
   </p>
   
    <p>
  <span class="function">RandomEncounterText() returns string [E]</span>
  Select a random monster from the encounter, then get a random entry from the <i>comments</i> specified. You'll want to use this to replicate default encounter behaviour. See code below (or one of the example encounters).
   </p>
    <div class="code-container">
   <pre class="brush: lua;">function DefenseEnding() --This built-in function fires after the defense round ends.
    encountertext = RandomEncounterText()
end</pre>
  </div>
  <hr>
  <h3>Wave scripts</h3>
  <p>The following section is dedicated exclusively to wave scripts. We'll go over special functions and the arena object. As you can now create projectiles from the encounter as well, information about projectiles and their examples have been moved to the <i>API - Projectile management</i> section.</p>
     <p>
  <span class="function">The Arena object [W]</span>
  You can use this object to obtain information about the arena, or resize it.
   </p>
  <ul>
   <li>Arena.width (readonly) - the width of the arena in pixels, after resizing. Since the reference for the player and bullets is the arena's center, you can get the left/right side of the arena with -Arena.width/2 and Arena.width/2 respectively.</li>
   <li>Arena.height (readonly) - the height of the arena in pixels, after resizing. Like with width, you can get the bottom/top with -Arena.height/2 and Arena.height/2 respectively.</li>
   <li>Arena.currentwidth (readonly) - the <i>current</i> width of the arena in pixels. Differs from <i>width</i> in that it will accurately reflect the arena size in the middle of resizing, too.</li>
   <li>Arena.currentheight (readonly) - the <i>current</i> height of the arena in pixels. Differs from <i>height</i> in that it will accurately reflect the arena size in the middle of resizing, too.</li>
   <li>Arena.Resize(width, height) - Resizes the arena to the new size. Currently, monsters stay on top of the arena. This will be changed around the animation update.</li>
   <li>Arena.ResizeImmediate(width, height) - Resizes the arena without the animation.</li>
  </ul>
  
  <p>
  <span class="function">EndWave() [W]</span>
  Ends this wave immediately. You can only call this function from the Update function.
  </p>
</div>

<div class="tab-pane text-style" id="api-projectile">
<h2>Projectile management</h2>
<p>Projectile management is, starting from 0.2.0, available from both the encounter and the wave scripts. As a result it is now in its own section.</p>
<p>
  <span class="function">CreateProjectile(spritename, initial_x, initial_y) returns Bullet [E/W]</span>
  Create a bullet that you can store and modify, with its spawn position relative to the center of the arena. The hitbox of it will be, in this alpha build, a rectangle around your sprite. As the hitbox code is being rewritten very soon (it's high priority!) try to stick to bullets without extravagant shapes sticking out for now.
   </p>
   
      <p>
  <span class="function">CreateProjectileAbs(spritename, initial_x, initial_y) returns Bullet [E/W]</span>
  Same as CreateProjectile, but spawn position is relative to the bottom left of the screen instead of the arena's center.
   </p>
  
   <p>
   <span class="function">The Bullet object</span>
   This is what you use to move around the bullet and store values in it. You can store a bunch in a table and modify them. The functions and variables you can use on a Bullet are as follows.
   <ul>
    <li>Bullet.sprite - the Bullet's sprite component. See the Sprites &amp; Animation section for usage details. NOTE: Currently, modifying the sprite does not change the bullet's hitbox yet; it's always the original square of the bullet when it was created.</li>
    <li>Bullet.x (readonly) - The X position of this bullet, relative to the arena's center. A bullet at x=0 and y=0 will be at the center of the arena.</li>
    <li>Bullet.y (readonly) - The Y position of this bullet, relative to the arena's center.</li>
    <li>Bullet.absx (readonly) - The X position of this bullet, relative to the bottom left corner of the screen.</li>
    <li>Bullet.absy (readonly) - The Y position of this bullet, relative to the bottom left corner of the screen.</li>
    <li>Bullet.isactive (readonly) - Used to check if the bullet is still active. If the bullet has been removed, this will be false; otherwise true.</li>
    <li>Bullet.Move(x, y) - Move this bullet x pixels to the right and y pixels up. Negative x will move it to the left, and negative y will move it downwards.</li>
    <li>Bullet.MoveTo(x, y) - Move this bullet to this position immediately, relative to the arena's center.</li>
    <li>Bullet.MoveToAbs(x, y) - Move this bullet to this position immediately, relative to the bottom left corner of the screen.</li>
    <li>Bullet.Remove() - destroys this bullet. You can continue retrieving its x, y, absx and absy properties. Trying to move a removed bullet will give you a Lua error. If you're not sure your bullet still exists, check Bullet.isactive first.</li>
    <li>Bullet.SetVar(your_variable_name, value) - Set a variable on this bullet that you can retrieve with Bullet.GetVar(your_variable_name). Similar in use to SetGlobal(), but you can use this to store specific variables on a per-bullet basis.</li>
    <li>Bullet.GetVar(your_variable_name) - Get a variable that you previously set using Bullet.SetVar().</li>
    <li>Bullet.SendToTop() - Moves this bullet on top of all currently existing projectiles. Note that newly spawned projectiles are always on top by default; this function is mostly to move existing bullets to the top.</li>
    <li>Bullet.SendToBottom() - Moves this bullet below all currently existing projectiles.</li>
   </ul>
   <p>Here is an example of a bullet that chases you pretty fast, but slows down as it gets closer. You have to keep moving to dodge it. This is a fairly basic example that makes use of the Player object.</p>
<div class="code-container">
<pre class="brush: lua;">
oursprite = "hOI!!!!"
--Create a new bullet, starting in the upper right corner.
chasingbullet = CreateProjectile(oursprite, Arena.width/2, Arena.height/2)
--Set initial speed of 0 in both directions.
chasingbullet.SetVar('xspeed', 0)
chasingbullet.SetVar('yspeed', 0)

function Update()
    -- Get the x/y difference between the player and bullet
    local xdifference = Player.x - chasingbullet.x
    local ydifference = Player.y - chasingbullet.y
    -- We create a new speed by first halving the original speed
    -- Then we add a small fraction of the position difference between the player and bullet.
    -- The result is a bullet that moves faster as it's further away, and slower when it's closer.
    -- The value we're dividing by is experimental. Experimenting with numbers is essential!
    local xspeed = chasingbullet.GetVar('xspeed') / 2 + xdifference / 100
    local yspeed = chasingbullet.GetVar('yspeed') / 2 + ydifference / 100
    -- Now move the bullet...
    chasingbullet.Move(xspeed, yspeed)
    -- ...and store our new speeds.
    chasingbullet.SetVar('xspeed', xspeed)
    chasingbullet.SetVar('yspeed', yspeed)
end
</pre></div>
   <p>Below is an example of a fully scripted Wave using most of these functions. It will spawn a projectile above the arena (assuming a width/height of 155/130), give it a random speed in the X direction, and drop it downwards. If it hits the bottom border of the arena, it'll bounce back up. Otherwise it'll continue falling off the screen.</p>
<div class="code-container">
<pre class="brush: lua;">
spawntimer = 0
bullets = {}

-- This happens every frame while you're defending. --
function Update()
    spawntimer = spawntimer + 1 --Add 1 to the counter every frame
    
    -- This part takes care of bullet spawning. --
    if spawntimer%30 == 0 then  --This happens every 30 frames.
        local posx = 30 - math.random(60) --Set a random X position between -30 and 30
        local posy = 65 --and set the Y position to 65, on the top edge of the arena.
        local bullet = CreateProjectile('hOI!!!!', posx, posy) -- Create projectile with sprite hOI!!!!.png
        bullet.SetVar('velx', 1 - 2*math.random()) -- We'll use this for horizontal speed. Random between -1/1
        bullet.SetVar('vely', 0) -- We'll use this for fall speed. We're starting without downward movement.
        table.insert(bullets, bullet) -- Add this new Bullet object to the bullets table up there.
    end
    
    -- This part updates every bullet in the bullets table. --
    for i=1,#bullets do -- #bullets in Lua means 'length of bullets table'.
        local bullet = bullets[i] -- For convenience, so we don't have to use bullets[i]
        local velx = bullet.GetVar('velx') -- Get the X/Y velocity we just set
        local vely = bullet.GetVar('vely')
        local newposx = bullet.x + velx -- New position will be old position + velocity
        local newposy = bullet.y + vely
        if(bullet.x > -Arena.width/2 and bullet.x < Arena.width/2) then -- Are we inside the arena (horizontally)?
            if(bullet.y < -Arena.height/2 + 8) then -- And did we go past the bottom edge?
                bullet.MoveTo(bullet.x, -Arena.height/2 + 8) -- Don't move it past the edge!
                -- Note the +8; I know the bullet sprite I'm using is 16x16.
                -- Without adding 8 it'll be inside the edge.
                vely = 4 --reverse bounce direction
            end
        end
        vely = vely - 0.04 -- Apply gravity
        bullet.MoveTo(newposx, newposy) -- and finally, move our bullet
        bullet.SetVar('vely', vely) -- and store our new fall speed into the bullet again.
    end
end</pre></div>

  <p>
  <span class="function">OnHit(bullet)</span>
  Every time a bullet collides with a player, this function gets called on the script that created the projectile. The bullet object in this function can be modified if you feel like it. For more information on the bullet object, see the documentation above.<br>
  <br>
  If you implement this function in your script, you have to define manually what should happen after bullet collision. This is what allows you to create orange, cyan and green projectiles, and much much more. If you don't implement this function in your wave script, it'll stick to the default of dealing 3 damage on hit. Below are multiple examples of how to use this function.</p>
    <div class="code-container">
  <pre class="brush:lua;">
--Defining your own damage for this wave
function OnHit(bullet)
    Player.Hurt(10)
end
  
--Replicating cyan bullet functionality
function OnHit(bullet)
    if Player.isMoving then
        Player.Hurt(5)
    end
end

--Replicating orange bullet functionality; opposite condition of cyan
function OnHit(bullet)
    if not Player.isMoving then
        Player.Hurt(5)
    end
end

--Replicating green bullet functionality
function OnHit(bullet)
    Player.Heal(1)
    bullet.Remove()
end
</pre></div>  
</div>

<div class="tab-pane text-style" id="api-animation">
<h2>Sprites &amp; Animation</h2>
<p>Projectile management is, starting from 0.2.0, available from both the encounter and the wave scripts. As a result it is now in its own section.</p>
<p>
  <span class="function">CreateSprite(spritename) returns Sprite [E/W]</span>
  Create a sprite in the far bottom left of the screen (at 0, 0) that you can modify in many ways.
   </p>
  
   <p>
   <span class="function">The Sprite object</span>
   The Sprite object has many controls intended for animation. There is a working intermediate example included in the Examples folder.
   <ul>
<li>sprite.isactive (readonly) - true if sprite has been removed, false otherwise.</li>
<li>sprite.x - horizontal position of sprite relative to bottom left of screen, measured from its pivot/anchor point (center by default). If parented, x position is relative to parent</li>
<li>sprite.y - vertical position of sprite relative to bottom left of screen, measured from its pivot/anchor point (center by default). If parented, y position is relative to parent</li>
<li>sprite.xscale - horizontal scaling of sprite (1.0 by default). 2.0 is twice as large, 0.5 half as large</li>
<li>sprite.yscale - vertical scaling of sprite (1.0 by default). 2.0 is twice as large, 0.5 half as large</li>
<li>sprite.width (readonly) - width of this sprite's image in pixels. This never changes until the sprite itself is swapped</li>
<li>sprite.height (readonly) - height of this sprite's image in pixels. This never changes until the sprite itself is swapped</li>
<li>sprite.color - get or set the color, as a table of 3 values from 0 to 1. For example, sprite.color = {1.0, 0.0, 0.0} makes it red. This actually overlays the sprite's original color, so if you want full control over the color make sure your sprite is white. Black areas are not affected by coloration.</li>
<li>sprite.alpha - get or set sprite transparency, from 0 to 1.</li>
<li>sprite.rotation - get or set sprite rotation, in degrees. It's clamped between 0 and 360, so if you change it to 365 it becomes 5.</li>
<li>sprite.Set("new_sprite") - change the sprite's image. It retains its scaling and rotation. If you have an animation running with SetAnimation, the animation will override your sprite change.</li>
<li>sprite.SetParent(other_sprite_object) - parents <i>sprite</i> to <i>other_sprite_object</i>. This will make the original sprite move along with the object it's parented to.</li>
<li>sprite.SetPivot(x, y) - changes the point the sprite rotates/scales around; (0,0) is bottom left of sprite, (1,1) is top right. You can have values outside of the 0-1 range, too.</li>
<li>sprite.SetAnchor(x, y) - change the point your sprite anchors to when moving. Mainly noticeable when rescaling the parent sprite, and you want to have this sprite stick to a certain edge of it. x/y should be in 0-1 range.</li>
<li>sprite.MoveTo(x, y) - same as setting x and y simultaneously.</li>
<li>sprite.MoveToAbs(x, y) - used to move a sprite to an absolute screen position, regardless of parent settings. The sprite itself will remain parented.</li>
<li>sprite.Scale(xscale, yscale) - same as setting xscale and yscale simultaneously</li>
<li>sprite.SetAnimation(sprite_table) to do frame-by-frame animation at 30FPS. Example: sprite.SetAnimation({"sans_head1", "sans_head2", "sans_head3"})</li>
<li>sprite.SetAnimation(sprite_table, time_per_frame) to do frame-by-frame animation with your own time between frames, in seconds. If time_per_frame is 1, it takes 1 second to move to the next sprite.</li>
<li>sprite.StopAnimation() - stop the frame-by-frame animation if it was running. Also changes back to the sprite it had before the animation, or whenever you last called sprite.Set().</li>
<li>sprite.SendToTop() - sends this sprite to the top of its layer's hierarchy. If a sprite has 5 children for instance, you can use this to rearrange them internally. However, child sprites will always appear on top of their parents, regardless of this function being called.</li>
<li>sprite.SendToBottom()  sends this sprite to the bottom of its layer's hierarchy. Similar rules apply as with SendToTop().</li>
<li>sprite.Remove() - remove this sprite. Calling anything other than isactive after this will give you an error.</li>

   </ul>
   <p>The animation script used in the example is shown below for reference.</p>
<div class="code-container">
<pre class="brush: lua;">
-- First, we can create the torso, legs and head.
sanstorso = CreateSprite("sans/sanstorso")
sanslegs = CreateSprite("sans/sanslegs")
sanshead = CreateSprite("sans/sanshead1")

--We parent the torso to the legs, so when you move the legs, the torso moves too. 
--We do the same for attaching the head to the torso.
sanstorso.SetParent(sanslegs)
sanshead.SetParent(sanstorso)

--Now we adjust the height for the individual parts so they look more like a skeleton and less like a pile of bones.
sanslegs.y = 240
sanstorso.y = -5 --The torso's height is relative to the legs they're parented to.
sanshead.y = 40 --The head's height is relative to the torso it's parented to.

--We set the torso's pivot point to halfway horizontally, and on the bottom vertically, 
--so we can rotate it around the bottom instead of the center.
sanstorso.SetPivot(0.5, 0)

--We set the torso's anchor point to the top center. Because the legs are pivoted on the bottom (so rescaling them only makes them move up),
--we want the torso to move along upwards with them.
sanstorso.SetAnchor(0.5, 1)
sanslegs.SetPivot(0.5, 0)

--Finally, we do some frame-by-frame animation just to show off the feature. You put in a list of sprites,
--and the time you want a sprite change to take. In this case, it's 1/2 of a second.
sanshead.SetAnimation({"sans/sanshead1", "sans/sanshead2", "sans/sanshead3"}, 1/2)

function AnimateSans()
    sanslegs.Scale(1, 1+0.1*math.sin(Time.time*2))
    sanshead.MoveTo(2*math.sin(Time.time), 40 + 2*math.cos(Time.time))
    sanshead.rotation = 10*math.sin(Time.time + 1)
    sanstorso.rotation = 10*math.sin(Time.time + 2)
end
</pre></div>

</div>

<div class="tab-pane text-style" id="mercy">
<h2>* YOU WON!<br>
* You earned 0 EXP and 0 gold.<br>
* also the nav menu is broken now</h2>
</div>


</div>
</div>

<div class="container">
<div class="col-xs-3"><img class="centerbt black" alt="Undertale fake button" src="img/fightbt_0.png" height="42"></div>
<div class="col-xs-3"><img class="centerbt black" alt="Undertale fake button" src="img/actbt_0.png" height="42"></div>
<div class="col-xs-3"><img class="centerbt black" alt="Undertale fake button" src="img/itembt_0.png" height="42"></div>
<div class="col-xs-3"><a href="#mercy" data-toggle="tab"><img class="centerbt black" alt="Undertale fake button" src="img/mercybt_0.png" width="110" height="42"></a></div>
</div>
    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script type="text/javascript" src="js/show_hide_comments.js"></script>
</body>
</html>